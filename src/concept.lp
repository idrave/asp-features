%*
Meanings of some atoms:
pred(P):            P is a predicate
arity(P, N)         The arity of P is N (integer)
const(X)            X is a constant (a grounded object)
state(S)            S is a state
hold(S, P, X)       Predicate P holds for tuple X in state S
belong(X, Y, S)     Tuple X belongs to concept or role Y in state S
valid(C)            Expression C is a concept generated by the grammar, and is not empty in all states
cost(C, N)          N is the number of grammar rules needed to generate C
conc(C)             Expression C represents a concept. No two elements of conc represent the same objects
                    over all states
role(R)             Expression R represents a role.

*%

%Upper bound in concept and role complexity
#const k=5.

%Rule for primitive concepts from unary predicates
belong(X, prim(P), S) :- const(X), pred(P), arity(P, 1), state(S), hold(S, P, X).
cost(prim(P), 1) :- belong(_, prim(P), _).

%Rule for universal concept
belong(X, univ, S) :- const(X), state(S).
cost(univ, 1).

%Rule for nominals
belong(X, nomi(X), S) :- const(X), state(S).
cost(nomi(X), 1) :- belong(_, nomi(X), _).

cbasic(C) :- C = (prim(_); univ; nomi(_)), cost(C, _).
valid(C) :- cbasic(C).

%Negation

belong(X, neg(C), S) :- const(X), cbasic(C), state(S), not belong(X, C, S).
cost(neg(C), 2) :- valid(neg(C)).
valid(neg(C)) :- cbasic(C), belong(_, neg(C), _).

%Rule for conjunction

is_and(and(C1, C2)) :- conc(and(C1, C2)).

valid_and(C1, C2) :- conc(C1), cost(C1, N1), conc(C2), cost(C2, N2), N1 + N2 < k, not is_and(C1),
                    not is_and(C2), C1 < C2.

valid_and(C1, and(C2, C3)) :- conc(C1), cost(C1, N1), conc(and(C2, C3)), cost(and(C2, C3), N2),
                    N1 + N2 < k, not is_and(C1), C1 < C2.

belong(X, and(C1, C2), S) :- const(X), valid_and(C1, C2), state(S), belong(X, C1, S), belong(X, C2, S).
valid(and(C1, C2)) :- belong(_, and(C1, C2), _).
cost(and(C1, C2), N1 + N2 + 1) :- valid(and(C1, C2)), cost(C1, N1), cost(C2, N2).

%Primitive roles and their inverse

belong((X, Y), r_prim(P), S) :- const(X), const(Y), pred(P), arity(P, 2), state(S), hold(S, P, (X, Y)).
belong((X, Y), inv(r_prim(P)), S) :- const(X), const(Y), pred(P), arity(P, 2), state(S), hold(S, P, (Y, X)).

r_basic(r_prim(P)) :- belong(_, r_prim(P), _).
r_basic(inv(R)) :- belong(_, inv(R), _).
role(R) :- r_basic(R).
cost(R, 1) :- r_basic(R).

%Transitive roles based on primitives and inverses
belong(XY, tran(R), S) :- r_basic(R), belong(XY, R, S).
belong((X, Y), tran(R), S) :- r_basic(R), belong((X, Z), R, S), belong((Z, Y), tran(R), S).
role(tran(R)) :- belong(_, tran(R), _).

cost(tran(R), 1) :- belong(_, tran(R), _).

%Define existential and universal restrictions on role-concept pairs

%role_conc: equivalent to R:C notation:
belong((X, Y), role_conc(R, C), S) :- role(R), conc(C), belong((X, Y), R, S), belong(Y, C, S).
belong((X, Y), neg(role_conc(R, C)), S) :- const(X), const(Y), role(R), conc(C), state(S),
                                        not belong((X, Y), role_conc(R, C), S).

%Negation of universal quantifier as existential quantifier of the negation:
belong(X, neg(uni(R, C)), S) :- conc(C), belong((X, Y), neg(role_conc(R, C)), S), cost(R, NR), cost(C, NC), NR + NC < k.

belong(X, uni(R, C), S) :- const(X), role(R), conc(C), state(S), not belong(X, neg(uni(R, C)), S),
                            cost(R, NR), cost(C, NC), NR + NC < k.

cost(uni(R, C), NR + NC + 1) :- valid(uni(R, C)), cost(R, NR), cost(C, NC).
valid(uni(R, C)) :- role(R), conc(C), belong(_, uni(R, C), _).

%Existential restriction:
belong(X, exi(R, C), S) :- belong((X, Y), role_conc(R, C), S), cost(R, NR), cost(C, NC), NR + NC < k.

cost(exi(R, C), NR + NC + 1) :- valid(exi(R, C)), cost(R, NR), cost(C, NC).
valid(exi(R, C)) :- role(R), conc(C), belong(_, exi(R, C), _).

% Guarantee non-redundancy in the set of concepts

differ(C1, C2) :- valid(C1), valid(C2), const(X), state(S), belong(X, C1, S), not belong(X, C2, S).
differ(C1, C2) :- valid(C1), valid(C2), const(X), state(S), not belong(X, C1, S), belong(X, C2, S).

equiv(C1, C2) :- valid(C1), valid(C2), not differ(C1, C2).

%From the sets of equivalent valid concepts, we take the one with least cost
%that appears before in clingo's total order
before(C1, C2) :- cost(C1, N1), cost(C2, N2), N1 < N2.
before(C1, C2) :- cost(C1, N1), cost(C2, N2), N1 = N2, C1 < C2.

%An expression is redundant if there is another expression with the same connotation in all states
%and such expression is already in the set of concepts, appearing before over the order we defined
redundant(C1) :- conc(C2), equiv(C1, C2), before(C2, C1).

%If an expression is valid and not redundant, we include it over the set of unique concepts
conc(C) :- valid(C), not redundant(C).
#show conc/1.