%*
Meanings of some atoms:
pred(P):            P is a predicate
arity(P, N)         The arity of P is N (integer)
const(X)            X is a constant (a grounded object)
state(S)            S is a state
hold(S, P, X)       Predicate P holds for tuple X in state S
belong(X, Y, S)     Tuple X belongs to concept or role Y in state S
valid(C)            Expression C is a concept generated by the grammar, and is not empty in all states
cost(C, N)          N is the number of grammar rules needed to generate C
conc(C)             Expression C represents a concept. No two elements of conc represent the same objects
                    over all states
role(R)             Expression R represents a role.

*%
#show.
#defined role/2.
#defined const/1.
#defined state/1.

#program primitive(depth).

%Rule for primitive concepts from unary predicates
exp(prim(P), depth) :- pred(P), arity(P, 1), depth = 1.
belong(X, prim(P), S) :- const(X), exp(prim(P), depth), state(S), hold(S, P, X).

%Rule for universal concept
belong(X, univ, S) :- const(X), state(S), exp(univ, depth).
exp(univ, depth) :- depth = 1.

%Rule for nominals
belong(X, nomi(X), S) :- const(X), exp(nomi(X), depth), state(S).
exp(nomi(X), depth) :- const(X), depth = 1.

#program negation(depth).

%Negation
belong(X, neg(C), S) :- const(X), exp(neg(C), depth), state(S), not belong(X, C, S).
exp(neg(C), depth) :- conc(C, depth-1), depth = 2.

#program conjunction(depth, input1, input2).

:- not depth = input1 + input2 + 1.

%Rule for conjunction

is_and(and(C1, C2)) :- conc(and(C1, C2), _).

exp(and(C1, C2), depth) :-
    conc(C1, input1), conc(C2, input2), input1 < input2.

exp(and(C1, C2), depth) :-
    conc(C1, input1), conc(C2, input2), input1 = input2, C1 < C2.


belong(X, and(C1, C2), S) :-    
    const(X), exp(and(C1, C2), depth), state(S),
    belong(X, C1, S), belong(X, C2, S).

#program roles.

%Primitive roles and their inverse

belong((X, Y), r_prim(P), S) :- const(X), const(Y), pred(P), arity(P, 2), state(S), hold(S, P, (X, Y)).
belong((X, Y), inv(r_prim(P)), S) :- const(X), const(Y), pred(P), arity(P, 2), state(S), hold(S, P, (Y, X)).

r_basic(r_prim(P)) :- belong(_, r_prim(P), _).
r_basic(inv(R)) :- belong(_, inv(R), _).
role(R, 1) :- r_basic(R).

%Transitive roles based on primitives and inverses
belong(XY, tran(R), S) :- r_basic(R), belong(XY, R, S).
belong((X, Y), tran(R), S) :- r_basic(R), belong((X, Z), R, S), belong((Z, Y), tran(R), S).
role(tran(R), 1) :- belong(_, tran(R), _).

#show role(Role, Cost) : role(Role, Cost).
#show belong(Tuple, Role, State) : belong(Tuple, Role, State), role(Role, _).

#program equal_role(depth).

% Define concepts of the form R = R' for roles R and R'

belong(X, eq(R1, R2), S) :- const(X), role(R1, _), role(R2, _), state(S), exp(eq(R1, R2), depth),
                            belong((X, Y), R1, S) : belong((X, Y), R2, S), const(Y);
                            belong((X, Y), R2, S) : belong((X, Y), R1, S), const(Y);
                            R1 < R2.

exp(eq(R1, R2), depth) :- role(R1, 1), role(R2, 1), depth = 3.

#program uni(depth).

%Define existential and universal restrictions on role-concept pairs

belong(X, uni(R, C), S) :-  
    const(X), exp(uni(R, C), depth), state(S),
    belong((X, Y), R, S) : const(Y);
    belong(Y, C, S) : const(Y).

exp(uni(R, C), depth) :- role(R, 1), conc(C, depth-2).

#program exi(depth).

%Existential restriction:
belong(X, exi(R, C), S) :-
    const(X), const(Y), exp(exi(R, C), depth), state(S),
    belong((X, Y), R, S), belong(Y, C, S).

exp(exi(R, C), depth) :- role(R, 1), conc(C, depth-2).

#program keep_exp.
#defined exp/2.
#defined keep/1.
cardinality(C, N, S) :- exp(C, _), state(S), N = #count{X : belong(X, C, S)}.

keep(exp(C, N)) :- exp(C, N), belong(_, C, _).
#show exp(C, N) : keep(exp(C, N)).
#show belong(X, C, S) : keep(exp(C, _)), belong(X, C, S).
#show cardinality(C, N, S) : keep(exp(C, _)), cardinality(C, N, S).